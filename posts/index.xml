<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on SlowCloud_</title><link>https://slowcloud.github.io/posts/</link><description>Recent content in Posts on SlowCloud_</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Tue, 06 May 2025 09:21:09 +0000</lastBuildDate><atom:link href="https://slowcloud.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>스프링 프레임워크 `@Async`를 알아보자</title><link>https://slowcloud.github.io/posts/2025-05-06-%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3-async%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1/</link><pubDate>Tue, 06 May 2025 09:21:09 +0000</pubDate><guid>https://slowcloud.github.io/posts/2025-05-06-%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3-async%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1/</guid><description>&lt;p>&lt;code>@Async&lt;/code>를 사용하면 해당 메소드는 비동기로 실행이 된다. 반환값이 &lt;code>void&lt;/code>거나, &lt;code>Future&lt;/code>인 경우에만 비동기가 적용되며, 그 외의 경우에는 비동기로 실행되지 않고 무시된다. 스프링 프레임워크에서 제공하는 &lt;code>ListenableFuture&lt;/code>와 Java 8 이후에서 제공하는 &lt;code>CompletableFuture&lt;/code>도 비동기를 제공한다.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>아래는 예시 코드이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">VirtualService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Logger logger &lt;span style="color:#f92672">=&lt;/span> LoggerFactory.&lt;span style="color:#a6e22e">getLogger&lt;/span>(VirtualService.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 반환값이 있는 비동기 메소드&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Async&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CompletableFuture&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">DoSomething&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;we got %d!&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">formatted&lt;/span>(n));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(1000L);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> CompletableFuture.&lt;span style="color:#a6e22e">completedFuture&lt;/span>(n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>스프링 프레임워크에서는 &lt;code>Executor&lt;/code>를 빈으로 등록하면 이를 비동기 처리에 사용한다. 스프링 프레임워크에서는 &lt;code>Executor&lt;/code>를 상속한 &lt;code>TaskExecutor&lt;/code>를 주로 사용하며, 미리 만들어 둔 구현체들이 존재한다.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 그 중 &lt;code>ConcurrentTaskExecutor&lt;/code>, &lt;code>ThreadPoolTaskExecutor&lt;/code>를 사용하면 가상 쓰레드를 사용할 수 있다. &lt;code>setVirtualThread&lt;/code>를 실행하면 되며, &lt;code>true&lt;/code>를 넣으면 가상 쓰레드를 사용한다.&lt;/p></description></item></channel></rss>
<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>스프링 프레임워크 `@Async`를 알아보자 | SlowCloud_</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content='@Async를 사용하면 해당 메소드는 비동기로 실행이 된다. 반환값이 void거나, Future인 경우에만 비동기가 적용되며, 그 외의 경우에는 비동기로 실행되지 않고 무시된다. 스프링 프레임워크에서 제공하는 ListenableFuture와 Java 8 이후에서 제공하는 CompletableFuture도 비동기를 제공한다.1
아래는 예시 코드이다.
@Service
public class VirtualService {

    private final Logger logger = LoggerFactory.getLogger(VirtualService.class);

    // 반환값이 있는 비동기 메소드
    @Async
    public CompletableFuture<Integer> DoSomething(int n) throws InterruptedException {
        logger.info("we got %d!".formatted(n));

        // do something
        Thread.sleep(1000L);
        
        return CompletableFuture.completedFuture(n);
    }

}
스프링 프레임워크에서는 Executor를 빈으로 등록하면 이를 비동기 처리에 사용한다. 스프링 프레임워크에서는 Executor를 상속한 TaskExecutor를 주로 사용하며, 미리 만들어 둔 구현체들이 존재한다.2 그 중 ConcurrentTaskExecutor, ThreadPoolTaskExecutor를 사용하면 가상 쓰레드를 사용할 수 있다. setVirtualThread를 실행하면 되며, true를 넣으면 가상 쓰레드를 사용한다.'><meta name=generator content="Hugo 0.147.1"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css><link rel=canonical href=https://slowcloud.github.io/posts/2025-05-06-%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3-async%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1/><meta property="og:url" content="https://slowcloud.github.io/posts/2025-05-06-%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3-async%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1/"><meta property="og:site_name" content="SlowCloud_"><meta property="og:title" content="스프링 프레임워크 `@Async`를 알아보자"><meta property="og:description" content='@Async를 사용하면 해당 메소드는 비동기로 실행이 된다. 반환값이 void거나, Future인 경우에만 비동기가 적용되며, 그 외의 경우에는 비동기로 실행되지 않고 무시된다. 스프링 프레임워크에서 제공하는 ListenableFuture와 Java 8 이후에서 제공하는 CompletableFuture도 비동기를 제공한다.1
아래는 예시 코드이다.
@Service public class VirtualService { private final Logger logger = LoggerFactory.getLogger(VirtualService.class); // 반환값이 있는 비동기 메소드 @Async public CompletableFuture<Integer> DoSomething(int n) throws InterruptedException { logger.info("we got %d!".formatted(n)); // do something Thread.sleep(1000L); return CompletableFuture.completedFuture(n); } } 스프링 프레임워크에서는 Executor를 빈으로 등록하면 이를 비동기 처리에 사용한다. 스프링 프레임워크에서는 Executor를 상속한 TaskExecutor를 주로 사용하며, 미리 만들어 둔 구현체들이 존재한다.2 그 중 ConcurrentTaskExecutor, ThreadPoolTaskExecutor를 사용하면 가상 쓰레드를 사용할 수 있다. setVirtualThread를 실행하면 되며, true를 넣으면 가상 쓰레드를 사용한다.'><meta property="og:locale" content="ko_kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-06T09:21:09+00:00"><meta property="article:modified_time" content="2025-05-06T09:21:09+00:00"><meta property="article:tag" content="Spring Boot"><meta property="article:tag" content="Spring Framework"><meta itemprop=name content="스프링 프레임워크 `@Async`를 알아보자"><meta itemprop=description content='@Async를 사용하면 해당 메소드는 비동기로 실행이 된다. 반환값이 void거나, Future인 경우에만 비동기가 적용되며, 그 외의 경우에는 비동기로 실행되지 않고 무시된다. 스프링 프레임워크에서 제공하는 ListenableFuture와 Java 8 이후에서 제공하는 CompletableFuture도 비동기를 제공한다.1
아래는 예시 코드이다.
@Service public class VirtualService { private final Logger logger = LoggerFactory.getLogger(VirtualService.class); // 반환값이 있는 비동기 메소드 @Async public CompletableFuture<Integer> DoSomething(int n) throws InterruptedException { logger.info("we got %d!".formatted(n)); // do something Thread.sleep(1000L); return CompletableFuture.completedFuture(n); } } 스프링 프레임워크에서는 Executor를 빈으로 등록하면 이를 비동기 처리에 사용한다. 스프링 프레임워크에서는 Executor를 상속한 TaskExecutor를 주로 사용하며, 미리 만들어 둔 구현체들이 존재한다.2 그 중 ConcurrentTaskExecutor, ThreadPoolTaskExecutor를 사용하면 가상 쓰레드를 사용할 수 있다. setVirtualThread를 실행하면 되며, true를 넣으면 가상 쓰레드를 사용한다.'><meta itemprop=datePublished content="2025-05-06T09:21:09+00:00"><meta itemprop=dateModified content="2025-05-06T09:21:09+00:00"><meta itemprop=wordCount content="194"><meta itemprop=keywords content="@Async,스프링,비동기"><meta name=twitter:card content="summary"><meta name=twitter:title content="스프링 프레임워크 `@Async`를 알아보자"><meta name=twitter:description content='@Async를 사용하면 해당 메소드는 비동기로 실행이 된다. 반환값이 void거나, Future인 경우에만 비동기가 적용되며, 그 외의 경우에는 비동기로 실행되지 않고 무시된다. 스프링 프레임워크에서 제공하는 ListenableFuture와 Java 8 이후에서 제공하는 CompletableFuture도 비동기를 제공한다.1
아래는 예시 코드이다.
@Service public class VirtualService { private final Logger logger = LoggerFactory.getLogger(VirtualService.class); // 반환값이 있는 비동기 메소드 @Async public CompletableFuture<Integer> DoSomething(int n) throws InterruptedException { logger.info("we got %d!".formatted(n)); // do something Thread.sleep(1000L); return CompletableFuture.completedFuture(n); } } 스프링 프레임워크에서는 Executor를 빈으로 등록하면 이를 비동기 처리에 사용한다. 스프링 프레임워크에서는 Executor를 상속한 TaskExecutor를 주로 사용하며, 미리 만들어 둔 구현체들이 존재한다.2 그 중 ConcurrentTaskExecutor, ThreadPoolTaskExecutor를 사용하면 가상 쓰레드를 사용할 수 있다. setVirtualThread를 실행하면 되며, true를 넣으면 가상 쓰레드를 사용한다.'></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">SlowCloud_</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">스프링 프레임워크 `@Async`를 알아보자</h1><time class="f6 mv4 dib tracked" datetime=2025-05-06T09:21:09Z>May 6, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><code>@Async</code>를 사용하면 해당 메소드는 비동기로 실행이 된다. 반환값이 <code>void</code>거나, <code>Future</code>인 경우에만 비동기가 적용되며, 그 외의 경우에는 비동기로 실행되지 않고 무시된다. 스프링 프레임워크에서 제공하는 <code>ListenableFuture</code>와 Java 8 이후에서 제공하는 <code>CompletableFuture</code>도 비동기를 제공한다.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>아래는 예시 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VirtualService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Logger logger <span style=color:#f92672>=</span> LoggerFactory.<span style=color:#a6e22e>getLogger</span>(VirtualService.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 반환값이 있는 비동기 메소드</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Async</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>DoSomething</span>(<span style=color:#66d9ef>int</span> n) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;we got %d!&#34;</span>.<span style=color:#a6e22e>formatted</span>(n));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do something</span>
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(1000L);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> CompletableFuture.<span style=color:#a6e22e>completedFuture</span>(n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>스프링 프레임워크에서는 <code>Executor</code>를 빈으로 등록하면 이를 비동기 처리에 사용한다. 스프링 프레임워크에서는 <code>Executor</code>를 상속한 <code>TaskExecutor</code>를 주로 사용하며, 미리 만들어 둔 구현체들이 존재한다.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 그 중 <code>ConcurrentTaskExecutor</code>, <code>ThreadPoolTaskExecutor</code>를 사용하면 가상 쓰레드를 사용할 수 있다. <code>setVirtualThread</code>를 실행하면 되며, <code>true</code>를 넣으면 가상 쓰레드를 사용한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@EnableAsync</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncConfiguration</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Executor <span style=color:#a6e22e>taskExecutor</span>() {
</span></span><span style=display:flex><span>		ThreadPoolTaskExecutor executor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolTaskExecutor();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// init</span>
</span></span><span style=display:flex><span>		executor.<span style=color:#a6e22e>setCorePoolSize</span>(10);
</span></span><span style=display:flex><span>		executor.<span style=color:#a6e22e>setMaxPoolSize</span>(10);
</span></span><span style=display:flex><span>		executor.<span style=color:#a6e22e>setQueueCapacity</span>(100);
</span></span><span style=display:flex><span>		executor.<span style=color:#a6e22e>setThreadNamePrefix</span>(<span style=color:#e6db74>&#34;virtual-&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 가상쓰레드 사용 설정</span>
</span></span><span style=display:flex><span>		executor.<span style=color:#a6e22e>setVirtualThreads</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		executor.<span style=color:#a6e22e>initialize</span>();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> executor;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>스프링부트에서는 <code>application.properties</code>에서 <code>spring.threads.virtual.enabled=true</code>를 작성하면 된다.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># use virtual threads</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>spring.threads.virtual.enabled</span><span style=color:#f92672>=</span><span style=color:#e6db74>true</span>
</span></span></code></pre></div><p><code>@Async</code>를 사용하면 <code>Executor</code> 등 쓰레드 설정을 스프링 설정 단계에서 관리할 수 있다는 장점이 있다.</p><p>스프링 공식 가이드와 예시 리포지토리도 존재한다.</p><h2 id=참고>참고</h2><ul><li><a href=https://spring.io/guides/gs/async-method>스프링 공식 비동기 가이드</a></li><li><a href=https://github.com/spring-guides/gs-async-method>스프링 공식 비동기 예시 리포지토리</a></li><li><a href=https://docs.spring.io/spring-framework/reference/integration/scheduling.html#page-title>스프링 프레임워크 Task Execution & Scheduling</a></li><li><a href=https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html#page-title>스프링 부트 Task Execution & Scheduling</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-annotation-support-async>https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-annotation-support-async</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-task-executor-types>https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-task-executor-types</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html#page-title>https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html#page-title</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><ul class=pa0><li class="list di"><a href=/tags/spring-boot/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Spring Boot</a></li><li class="list di"><a href=/tags/spring-framework/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Spring Framework</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://slowcloud.github.io/>&copy; SlowCloud_ 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>